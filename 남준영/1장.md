# 1장 리액트 훅을 이용한 마이크로 상태 관리

리엑트에서 상태는 사용자 인터페이스(UI)를 나타내는 모든 데이터를 말한다. 리엑트 훅이 나오기 전까지는 중앙 집중형 상태 관리 라이브러리를 사용했지만 리엑트 훅으로 인해 새로운 방법이 생겼다.

(폼 상태, 서버 캐시 상태 관리)

서버 상태를 주로 다루는 애플리케이션이라면 소수의 전역 상태만 필요할 것이고, 풍부한 그래픽을 제공하는 경우는 많은 전역 상태가 필요로 한다. 이렇듯 범용적인 상태 관리를 위한 방법은 가벼워야 하며, 개발자는 요구사항에 따라 적절한 방법을 선택해야 한다. 이를 가르켜 마이크로 상태 관리라고 한다.

## 리엑트 훅 사용

기본적인 리엑트 훅에는 useState, useReducer, useEffect가 있다. 리엑트 훅은 서스펜스, 동시성 렌더링과 함께 작동하도록 설계 및 개발되었다.

\*서스펜스: 데이터 불러오기를 위한 서스펜스는 비동기 처리에 대한것.

\*동시성 렌더링: 렌더링 프로세스를 청크로 분할해서 중앙 처리 장치(CPU)가 장시간 차단되는 것을 방지

### useState

```jsx
const init = () => 0; // 지연 초기화 (mount 될 때 한번만 실행)

const useCount = () => {
	const [count, setCount] = useState(init);
	return [count, setCount];
};

const Component = () => {
	const [count, setCount] = **useCount**();
}
```

useCount로 이름을 지정하면 코드의 가독성이 좋아진다. 또한 Component에서 분리됐으므로 독립적으로 관리가 가능하다.

### useReducer

```jsx
const init = (count) => ({count, text: 'hi')} // 지연 초기화 (똑같이 mount 시 한번만) 사용: useReducer(reducer,0,init)

const reducer = (state, action) => {
	switch(action.type) {
			case 'INC':
				return {...state, count: state.count +1 }
			case 'SET_TEXT':
				if (!action.text) return state // 베일 아웃 (리 렌더링x)
				return {...state, text: action.text}
			default:
				....
		}
}

const Component = () => {
	const [state, dispatch] = **useReducer**(
		reducer, // reducer fucntion
		{ count: 0, text: 'hi'} // initial
	);

	...
	onClick={() => dispatch({type: 'INC'})
}
```

useState는 useReducer로 구현되어 있기 때문에 서로를 대체가 가능하다.

reducer와 init을 훅이나 컴포넌트 외부에서 정의할 수 있는 점은 useReducer에서만 가능하다. 이러한 특별한 경우를 제외하고는 두개를 취향것 선택하면 된다.

---

## Question

### **질문 1: useState와 useReducer의 차이점은 무엇이며, 언제 각각을 사용하는 것이 더 적합한가요?**

### 답변:

**`useState`**는 단순한 상태 관리에 적합하며, 상태 로직이 복잡하지 않을 때 주로 사용됩니다. 예를 들어, 카운터나 텍스트 입력과 같이 단일 값의 업데이트를 다룰 때 **`useState`**를 사용하는 것이 간결하고 직관적입니다.

반면, **`useReducer`**는 상태 업데이트 로직이 보다 복잡하거나 여러 하위 값이 포함된 상태를 관리할 때 유용합니다. 액션을 기반으로 다양한 상태 변화를 처리할 수 있으며, 상태 업데이트 로직을 외부 함수(reducer)로 분리할 수 있어서 테스트하기 용이하고, 컴포넌트 로직을 보다 깔끔하게 유지할 수 있습니다. 또한, **`useReducer`**는 동시성 렌더링과 서스펜스와 같은 리액트의 고급 기능을 사용할 때 예측 가능한 상태 전이를 제공합니다.

### **질문 2: 리액트에서 마이크로 상태 관리란 무엇이며, 왜 중요한가요?**

### 답변:

마이크로 상태 관리는 리액트 애플리케이션에서 작은 범위의 컴포넌트 또는 기능에 국한된 상태 관리 방식을 말합니다. 이 방식은 애플리케이션의 전체 상태를 전역적으로 관리하는 대신, 필요한 곳에서만 상태를 관리하여 더 가볍고 효율적인 상태 관리를 가능하게 합니다.

이러한 접근 방식은 상태 관리 로직을 분산시켜, 컴포넌트 또는 기능별로 상태를 독립적으로 관리할 수 있게 합니다. 이는 코드의 재사용성과 모듈성을 향상시키며, 대규모 애플리케이션에서 상태 관리의 복잡성을 줄이는 데 도움이 됩니다. 또한, 마이크로 상태 관리는 개발자가 애플리케이션의 특정 요구사항에 맞춰 더 유연하게 상태 관리 전략을 선택할 수 있게 해주며, 애플리케이션의 성능을 최적화하는 데에도 기여할 수 있습니다.

### **질문 3: 리액트의 서스펜스와 동시성 렌더링은 무엇이며, 어떻게 리액트 훅과 함께 사용될 수 있나요?**

### 답변:

서스펜스는 리액트가 비동기 작업을 "기다리는" 방법을 제공하는 기능입니다. 예를 들어, 데이터 불러오기와 같은 비동기 작업이 완료될 때까지 대기하고, 그 동안 로딩 플레이스홀더와 같은 대체 UI를 표시할 수 있습니다. 이는 리액트 앱에서 비동기 데이터를 더 쉽고 선언적으로 처리할 수 있게 해줍니다.

동시성 렌더링(Concurrent Rendering)은 리액트가 여러 상태 변화를 동시에 준비할 수 있게 하는 기능입니다. 이를 통해 애플리케이션이 더 반응적이 될 수 있으며, 사용자와의 상호작용이나 애니메이션 등에서 더 나은 성능을 제공합니다. 동시성 렌더링은 작업 우선순위를 지정할 수 있어, 중요한 업데이트는 빠르게 처리하고, 그렇지 않은 업데이트는 나중으로 미룰 수 있습니다.

리액트 훅과 함께 서스펜스와 동시성 렌더링을 사용하는 방법은 다음과 같습니다:

- **`useEffect`**와 같은 훅을 사용하여 데이터를 비동기적으로 불러오고, 서스펜스를 사용하여 로딩 상태를 관리할 수 있습니다. 예를 들어, **`React.lazy`**와 **`Suspense`** 컴포넌트를 함께 사용하여 코드 스플리팅과 느린 네트워크 상황에서의 사용자 경험을 개선할 수 있습니다.
- 서스펜스와 동시성 렌더링을 활용하면, 데이터를 불러오는 동안 사용자 입력과 같은 중요한 작업을 중단하지 않고, UI의 상호작용성을 유지할 수 있습니다. **`useTransition`** 훅을 사용하여 관리할 수 있습니다. **`useTransition`**은 애플리케이션에서 비동기적으로 데이터를 로드할 때 발생할 수 있는 상태 업데이트를 조절할 수 있게 해주어, 사용자 경험을 크게 향상시킵니다.

서스펜스와 동시성 렌더링은 리액트의 성능과 사용자 경험을 향상시키는 데 중요한 역할을 하며, 리액트 훅과 함께 사용될 때 애플리케이션의 상태 관리와 비동기 처리를 더욱 효율적으로 만들어줍니다.
